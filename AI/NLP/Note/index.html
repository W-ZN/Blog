
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.2, mkdocs-material-9.0.5">
    
    
      
        <title>信息抽取 - W</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.558e4712.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.2505c338.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="" data-md-color-accent="">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="W" class="md-header__button md-logo" aria-label="W" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            W
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              信息抽取
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="W" class="md-nav__button md-logo" aria-label="W" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    W
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        介绍
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " data-md-toggle="__nav_2" type="checkbox" id="__nav_2" >
      
      
      
        <label class="md-nav__link" for="__nav_2" tabindex="0" aria-expanded="false">
          AI
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="AI" data-md-level="1">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          AI
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " data-md-toggle="__nav_2_1" type="checkbox" id="__nav_2_1" >
      
      
      
        <label class="md-nav__link" for="__nav_2_1" tabindex="0" aria-expanded="false">
          NLP
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="NLP" data-md-level="2">
        <label class="md-nav__title" for="__nav_2_1">
          <span class="md-nav__icon md-icon"></span>
          NLP
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Note.md" class="md-nav__link">
        Note
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Paper Reading.md" class="md-nav__link">
        Paper Reading
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="_1">信息抽取<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h1>
<h1 id="_2">信息抽取<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h1>
<p>信息抽取旨在从无结构的自然语言文本中抽取出结构化的信息</p>
<ol>
<li>
<p>知识抽取最重要的 3 个子任务：</p>
<ul>
<li>实体抽取 (识别)：命名实体识别，包括实体的检测与分类，一般 span 及其实体类别表示</li>
<li>关系抽取：一般 triplet 表示</li>
<li>事件抽取：多元关系，一般 record表示</li>
<li>观点抽取：一般 triplet 表示</li>
</ul>
</li>
</ol>
<p>![[IE Tasks.png|500]]</p>
<ol>
<li>
<p>相关竞赛、数据集：</p>
<ul>
<li>ACE：对 MUC 定义任务进行融合</li>
<li>KBP：四个独立任务、一个整合任务</li>
<li>SemEval：词义消歧评测</li>
</ul>
</li>
</ol>
<p>相关会议/数据集：MUC、ACE、KBP、SemEval、TREC etc.</p>
<h2 id="_3">实体抽取<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h2>
<p>实体抽取/命名实体识别 (NER) ，主要抽取的文本中的原子信息元素 (人名、组织/机构名、地理位置、事件/日期、字符值、金额值 etc.)。其关键词可以总结为两个：<strong>find</strong> &amp; <strong>classify</strong>，即 <strong>find</strong> 文本中的 entity，再对其进行分类。</p>
<h3 id="_4">主要应用<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h3>
<ul>
<li>命名实体用于索引与超链接</li>
<li>数据分析的准备步骤</li>
<li>关系抽取的准备步骤</li>
<li>QA 系统的答案形式大多都为命名实体</li>
</ul>
<h3 id="_5">抽取方法<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h3>
<h3 id="traditional-machine-learning">Traditional Machine Learning<a class="headerlink" href="#traditional-machine-learning" title="Permanent link">&para;</a></h3>
<p><strong>大致流程</strong></p>
<p><em>Training</em></p>
<ol>
<li>收集对应的训练文档</li>
<li>为每个 token 标记命名实体</li>
<li>设计特征提取方法</li>
<li>训练 sequence classifier 预测数据的 label</li>
</ol>
<p><em>Testing</em></p>
<ol>
<li>收集对应测试文档</li>
<li>运行 sequence classfier 标记 token</li>
<li>输出命名实体</li>
</ol>
<p><strong>标注与编码</strong></p>
<p>进行数据标注时，最常用的有两种 sequence labeling 的编码方式：IO/IOB encoding</p>
<p>对于 IO，若单词不为命名实体 (NE) 就标为 O (other)</p>
<p>对于 IOB，使用 I-PER 承接上一个 NE，若连续出现两个B-PER，则上一个 B 结束</p>
<h3 id="sequence-model">Sequence model<a class="headerlink" href="#sequence-model" title="Permanent link">&para;</a></h3>
<p>常见的序列模型有：</p>
<ul>
<li>有向图模型：如 HMM，生成式模型，假设特征之间相互独立，找到使得 <span class="arithmatex"><span class="MathJax_Preview">P(X|Y)</span><script type="math/tex">P(X|Y)</script></span> 最大的参数</li>
<li>无向图模型：如 CRF，判别式模型，没有特征独立的假设，找到使得 <span class="arithmatex"><span class="MathJax_Preview">P(X|Y</span><script type="math/tex">P(X|Y</script></span>) 最大的参数</li>
</ul>
<h3 id="deep-learning">Deep Learning<a class="headerlink" href="#deep-learning" title="Permanent link">&para;</a></h3>
<p><strong>LSTM + CRF</strong></p>
<p>端到端的判别式模型，LSTM 利用过去的输入特征，CRF 利用句子级的标注信息，有效利用过去与未来的标注预测当前标注。</p>
<p>![[LSTM+CRF.png|550]]</p>
<h2 id="_6">关系抽取<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h2>
<p><strong>关系抽取</strong> 需要从文本中抽取两个/多个实体之间的语义关系，主要方法有：</p>
<ul>
<li>基于模板的方法 (hand-written patterns)<ul>
<li>基于触发词/字符串</li>
<li>基于依存句法</li>
</ul>
</li>
<li>监督学习 (supervised machine learning)<ul>
<li>Machine Learning</li>
<li>Deep Learning</li>
</ul>
</li>
<li>半监督/无监督学习 (semi-supervised / unsupervised learning)<ul>
<li>Bootstrapping</li>
<li>Distant supervision</li>
<li>Unsupervised learning from the web  </li>
</ul>
</li>
</ul>
<h3 id="_7">基于模板的方法<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h3>
<h4 id="_8">基于触发词/字符串<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h4>
<p>首先是**基于字符串的 pattern**，例如 IS-A 关系</p>
<blockquote>
<p>Agar is a substance prepared from a mixture of red algae, <strong>such as</strong> Gelidium, for laboratory or industrial use</p>
</blockquote>
<p>基于 such as，可以判断其为 IS-A 关系，由此可以写出的规则为：</p>
<div class="highlight"><pre><span></span><code>“Y such as X ((, X)* (, and|or) X)”
“such Y as X”
“X or other Y”
“X and other Y”
“Y including X”
“Y, especially X”
</code></pre></div>
<p>其次对于特定实体，有**基于 NER 的 pattern**，使用 NER 标签帮助进行关系抽取</p>
<div class="highlight"><pre><span></span><code>•  located-in (ORGANIZATION, LOCATION)
•  founded (PERSON, ORGANIZATION)
•  cures (DRUG, DISEASE)
</code></pre></div>
<p>当然，也可以结合两种 pattern，对应的工具有 Stanford CoreNLP 的 tokensRegex</p>
<h4 id="_9">基于依存句法<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h4>
<p>通常可以以动词为起点构建规则，对节点上的词性和其边上的依存关系进行限定，流程为：</p>
<ol>
<li>对句子进行分词、词性标注、命名实体识别、依存分析等处理</li>
<li>根据句子依存语法树结构上匹配规则，每匹配一条规则就生成一个三元组</li>
<li>根据拓展规则对抽取到的三元组进行拓展</li>
<li>对三元组实体和触发词进一步抽取出关系</li>
</ol>
<h3 id="_10">监督学习<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h3>
<h4 id="machine-learning">Machine Learning<a class="headerlink" href="#machine-learning" title="Permanent link">&para;</a></h4>
<p><strong>Feature</strong></p>
<p>对于文本：</p>
<blockquote>
<p><strong>American Airlines</strong>, a unit of AMR, immediately matched the move, spokesman <strong>Tim Wagner</strong> said</p>
</blockquote>
<p>Mention 1 (M1)：<strong>American Airlines</strong></p>
<p>Mention 2 (M2)：<strong>Tim Wagner</strong></p>
<p>常用的 Feature 有：</p>
<p><strong>Word Features</strong></p>
<ul>
<li>M1 与 M2 的词条 (headwords) 及其组合 (combination)<ul>
<li>例，M1：Airlines，M2：Wagner，Combination：Airlines-Wagner</li>
</ul>
</li>
<li>M1 与 M2 中的词袋 (Bag of words) 与二元组 (bigrams)<ul>
<li>{American, Airlines, Tim, Wagner, American Airlines, Tim Wagner}</li>
</ul>
</li>
<li>M1/M2 左右特定位置的单词或二元组<ul>
<li>M2: -1 spokesman</li>
<li>M2: +1 said</li>
</ul>
</li>
<li>两个实体之间的词袋或二元组<ul>
<li>{a, AMR, of, immediately, matched, move, spokesman, the, unit}</li>
</ul>
</li>
</ul>
<p><strong>Named Entities Type and Mention Level Features</strong></p>
<ul>
<li>命名实体 (NE) 类型<ul>
<li>M1: ORG  </li>
<li>M2: PERSON</li>
</ul>
</li>
<li>2 命名实体的关联 (Concatenation)<ul>
<li>ORG-PERSON</li>
</ul>
</li>
<li>M1 与 M2 的实体级别 (NAME, NOMINAL, PRONOUN)  <ul>
<li>M1: NAME [it or he would be PRONOUN]  </li>
<li>M2: NAME [the company would be NOMINAL]</li>
</ul>
</li>
</ul>
<p><strong>Parse Features</strong></p>
<ul>
<li>词到词的基本句法块序列 (Base syntactic chunk sequence)  <ul>
<li>NP NP PP VP NP NP</li>
</ul>
</li>
<li>树到树的构成路径 (Constituent path) <ul>
<li>NP ↑ NP ↑ S ↑ S ↓ NP</li>
</ul>
</li>
<li>依赖路径 (Dependency path  )<ul>
<li>Airlines matched Wagner said</li>
</ul>
</li>
</ul>
<p><strong>Gazetteer and trigger word features</strong></p>
<ul>
<li>家庭触发列表：亲属关系术语<ul>
<li>parent, wife, husband, grandparent, etc.</li>
</ul>
</li>
<li>地名词典<ul>
<li>List of useful geo or geopolitical words  </li>
<li>Country name list  </li>
<li>Other sub-entities</li>
</ul>
</li>
</ul>
<p><strong>Classification</strong></p>
<p>分类器流程：</p>
<ul>
<li>预先定义好想提取的关系集合</li>
<li>选择相关的命名实体集合</li>
<li>寻找并标注数据<ul>
<li>选择有代表性的语料库</li>
<li>标记命名实体</li>
<li>人工标注实体间的关系</li>
<li>分成训练、开发、测试集</li>
</ul>
</li>
<li>设计特征</li>
<li>选择并训练分类器</li>
</ul>
<p>为了提高 efficiency，通常会训练两个分类器，第一个分类器是 yes/no 的二分类，判断命名实体间是否有关系，如果有关系，再送到第二个分类器，给实体分配关系类别。这样做的好处是通过排除大多数的实体对来加快分类器的训练过程，另一方面，对每个任务可以使用 task-specific feature-set</p>
<p>可以采用的分类器可以是 <strong>MaxEnt、Naive Bayes、SVM</strong> 等。</p>
<h4 id="deep-learning_1">Deep Learning<a class="headerlink" href="#deep-learning_1" title="Permanent link">&para;</a></h4>
<p>DL 方法分为两类：Pipeline 与 Joint Model</p>
<p>常用特征有：</p>
<ul>
<li>Position embeddings</li>
<li>Word embeddings</li>
<li>Knlowledge embeddings</li>
</ul>
<p>模型通常有 CNN / RNN + attention，损失函数一般 ranking loss 要优于交叉熵</p>
<p><strong>Pipeline</strong></p>
<p>将实体识别与关系分类作为两个完全独立的过程，不会相互影响，关系的识别判断依赖于实体识别的效果</p>
<p>如：CR-CNN、Att-CNN、Att-BLSTM</p>
<p><strong>Joint Model</strong></p>
<p>实体识别与关系分类的过程共同优化</p>
<p>如：LSTM-RNNs</p>
<h3 id="_11">半监督/无监督学习<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h3>
<h4 id="_12">半监督学习<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h4>
<p>半监督学习主要是利用少量的标注信息进行学习，该方面主要基于 Bootstrap (引导) 的方法，以及 distant supervision (远程监督) 方法。基于 Bootstrap 的方法主要是利用少量实例作为初始种子 (seed tuple) 的集合，然后利用 pattern 学习方法进行学习，通过不断迭代从非结构化数据中抽取实例。然后从新学到的实例中学习新的 pattern ，同时扩充 pattern 集合，寻找与发现新的潜在关系三元组。远程监督方法主要是对知识库与非结构化文本对齐来构建大量训练数据，减少模型对人工标注数据的依赖，增强模型的跨领域适应能力</p>
<p><strong>Bootstrapping</strong></p>
<ol>
<li>收集一组具有关系 <span class="arithmatex"><span class="MathJax_Preview">R</span><script type="math/tex">R</script></span> 的 seed pair</li>
<li>迭代：<ul>
<li>查找包含这些 pair 的 sentence</li>
<li>查看 pair 之间/周围的上下文，并将其概括以创建 patterns</li>
<li>使用 grep 的 patterns 获取更多 pair</li>
</ul>
</li>
</ol>
<p><strong>Distant supervision</strong></p>
<p>基本假设：两个实体如果在知识库中存在某种关系，则包含两个实体的非结构化句子均能表示出该种关系</p>
<p>步骤：
1. 从知识库抽取存在关系的实体对
2. 从非结构化文本中抽取含有实体对的句子作为训练样例，然后提取特征训练分类器</p>
<p>Distant Supervision 结合了 Bootstrapping 和监督学习的长处，使用一个大的 corpus 来得到海量的 seed example，然后从这些 example 中创建特征，最后与有监督的分类器相结合；与监督学习相似的是这种方法用大量特征训练了分类器，通过已有的知识进行监督，不需要用迭代的方法来扩充 pattern。  ；与无监督学习相似的是这种方法采用了大量没有标注的数据，对训练语料库中的 genre 并不敏感，适合泛化</p>
<p>如：PCNN + Attention</p>
<h4 id="_13">无监督学习<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h4>
<p><strong>Unsupervised learning from the web</strong>  </p>
<div class="highlight"><pre><span></span><code>1. Use parsed data to train a “trustworthy tuple” classifier
2. Single-pass extract all relations between NPs, keep if trustworthy
3. Assessor ranks relations based on text redundancy
</code></pre></div>
<h2 id="_14">事件抽取<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h2>
<p>与关系抽取相比，事件抽取同样需要从文本中抽取 predict 与其对应的 arguments，不同的是，关系抽取的问题是 binary 的，其两个 arguments 需在同一句中出现；而事件抽取则面对了了多个 arguments 和 modifiers，且可能分布在多个句子中，同时部分 arguments 可能不是必须的，这使得半监督学习中的几种方法应对该种情况时都比较困难</p>
<p>事件抽取的任务分为两大类：</p>
<ul>
<li>
<p>事件识别和抽取</p>
<p>从描述事件信息的文本中识别并抽取出事件信息并以结构化的形式呈现出来，包括发生的时间、地点、参与角色以及与之相关的动作或者状态的改变</p>
</li>
<li>
<p>事件检测与追踪</p>
<p>事件检测与追踪旨在将文本新闻流按照其报道的事件进行组织，为传统媒体多种来源的新闻监控提供核心技术，以便让用户了解新闻及其发展。具体而言，事件发现与跟踪包括三个主要任务：<strong>分割，发现和跟踪</strong>，将新闻文本分解为事件， 发现新的（不可预见的）事件，并跟踪以前报道事件的发展;事件发现任务又可细分为**历史事件发现**和**在线事件发现**两种形式，前者目标是从按时间排序的新闻文档中发现以前没有识别的事件，后者则是从实时新闻流中实时发现新的事件</p>
</li>
</ul>
<h3 id="_15">相关概念<a class="headerlink" href="#_15" title="Permanent link">&para;</a></h3>
<ul>
<li>事件描述 (Event Mention)
    描述事件的词组/句子/句群，包含一个 trigger 以及任意数量的 arguments</li>
<li>事件触发 (Event Trigger)
    事件描述中最能代表事件发生的词汇，决定事件类别的重要特征，一般为动词或名词</li>
<li>事件元素 (Event Argument)
    事件的重要信息/实体描述 (entity mention)，主要由实体、属性值等表达完整语义的细粒度单位组成</li>
<li>元素角色 (Argument Role)
    事件元素在事件中扮演的角色，事件元素与事件的语义关系，可以理解为 slot</li>
<li>事件类型 (Event Type)</li>
</ul>
<h3 id="_16">事件识别与抽取<a class="headerlink" href="#_16" title="Permanent link">&para;</a></h3>
<p>类似于从文本中找到特定类别的事件，然后进行填表</p>
<blockquote>
<p>Given a text document, an event extraction system should <strong>predict event triggers</strong> with specific <strong>sub-types</strong> and <strong>their arguments for each sentence</strong>.</p>
</blockquote>
<p>事件抽取任务的基础部分包括：</p>
<ul>
<li>识别事件触发词及事件类型</li>
<li>抽取事件元素，同时判断其角色</li>
<li>抽取描述事件的词组或句子</li>
</ul>
<p>事件抽取大多是分阶段进行，通常是由 trigger classifier 开始，若有 trigger，就将 trigger 及其上下文作为特征进行分类判断事件类型，再判断下一步的 argument classifier，对句子中的每个 entity  mention 进行分类，判断是否是 argument，如果是，则判定其角色</p>
<h4 id="_17">基于模式匹配的方法<a class="headerlink" href="#_17" title="Permanent link">&para;</a></h4>
<p>核心：句法 (syntactic)、语义约束 (semantic constraints)</p>
<p>基于人工编写的规则/语法树/正则表达式</p>
<h4 id="_18">基于人工标注语料<a class="headerlink" href="#_18" title="Permanent link">&para;</a></h4>
<ul>
<li>AutoSlog</li>
</ul>
<p>基本假设：  </p>
<div class="codehilite"><pre><span></span><code>1. 事件元素首次提及之处即可确定该元素与事件间的关系  
2. 事件元素周围的语句中包含了事件元素在事件中的角色描述
</code></pre></div>

<p>通过监督学习和人工审查来建立抽取规则。通过训练数据中已经填充好的槽（filled slot），AutoSlog 解析 slot 附近的句法结构，来自动形成抽取规则，由于这个过程产生的模板 too-general，所以需要人工来审核。本质上形成的是一个字典</p>
<ul>
<li>PALKA</li>
</ul>
<p>基本假设：</p>
<div class="codehilite"><pre><span></span><code>特定领域中高频出现的语言表达方式是可数的
</code></pre></div>

<h4 id="_19">基于弱监督<a class="headerlink" href="#_19" title="Permanent link">&para;</a></h4>
<p>人工标注耗时耗力，且存在一致性问题，而弱监督方法则无需对语料进行完全标注，只需人工对语料进行一定的预分类或者制定种子模板，由机器根据预分类语料或种子模板自动进行模式学习</p>
<ul>
<li>AutoSlog-TS</li>
<li>TIMES</li>
<li>NEXUS</li>
<li>GenPAM</li>
</ul>
<p>基于模式匹配的方法在特定领域中性能较好，知识表示简洁，便于理解和后续应用，但对于语言、领域和文档形式都有不同程度的依赖，覆盖度和可移植性较差</p>
<p>模式匹配的方法中，模板准确性是影响整个方法性能的重要因素。在实际应用中，模式匹配方法应用非常广泛，主要特点是高准确率低召回率，要提高召回率，一是要建立更完整的模板库，二是可以用半监督的方法来建 trigger 字典</p>
<h4 id="_20">基于统计<a class="headerlink" href="#_20" title="Permanent link">&para;</a></h4>
<p>建立在统计模型基础上，事件抽取方法可以分为 pipeline 和 joint model 两大类</p>
<h5 id="machine-learning_1">Machine Learning<a class="headerlink" href="#machine-learning_1" title="Permanent link">&para;</a></h5>
<p><strong>Pipeline</strong></p>
<p>将事件抽取任务转化为多阶段的分类问题（管道抽取），需要顺序执行下面的分类器：</p>
<ol>
<li><strong>事件触发词分类器（Trigger Classifier）</strong><br />
    判断词汇是否是事件触发词，以及事件类别</li>
<li><strong>元素分类器（Argument Classifier）</strong><br />
    词组是否是事件元素</li>
<li><strong>元素角色分类器（Role Classifier）</strong><br />
    判定元素的角色类别</li>
<li><strong>属性分类器（Attribute Classifier）</strong><br />
    判定事件属性</li>
<li><strong>可报告性分类器（Reportable-Event Classifier）</strong><br />
    判定是否存在值得报告的事件实例</li>
</ol>
<p>分类器可以用 MaxEnt, SVM。重点还是在于提取和集成有区分性的特征，包括 <strong>句子级信息</strong> 和 <strong>篇章级信息</strong></p>
<p><em>句子级信息</em>：与候选词相关的词法特征、上下文特征、实体特征、句法特征、语言学特征等</p>
<p><em>篇章级信息</em>：跨文档利用全局信息。对于一个句子级的抽取结果不仅要考虑当前的置信度，还要考虑与待抽取文本相关的文本对它的影响，以及全局信息如事件与话题的关系，事件与事件的共现信息等</p>
<p><strong>Joint Model</strong></p>
<p>分为 Joint Inference 和 Joint Modeling 两种</p>
<p><em>Joint Inference</em> 使用集成学习的思路，将各模型通过整体优化目标整合起来，可以通过整数规划等方法进行优化</p>
<p><em>Joint Modeling (Structured)</em> 又可以称为基于结构的方法，将事件结构看作依存树，抽取任务相应转化为依存树结构预测问题，触发词识别和元素抽取可以同时完成，共享隐层特征，使用搜索进行求解，避免了误差传播导致的性能下降，另外，全局特征也可以从整体的结构中学习得到，从而使用全局的信息来提升局部的预测</p>
<h5 id="deep-learning_2">Deep Learning<a class="headerlink" href="#deep-learning_2" title="Permanent link">&para;</a></h5>
<p>上面的方法在特征提取过程中还是会依赖依存分析、句法分析、词性标注等传统的外部 NLP 工具，还是会造成误差积累，另外有些语言和领域并没有这类处理工具，加之特征也需要人工设定，2015 年起基于深度学习的事件抽取方法逐渐成为研究热点，相比于传统机器学习，深度学习方法优势明显：</p>
<ol>
<li>减少对外部 NLP 工具的依赖 ， 甚至不依赖 NLP 工具 ， 建立成端对端的系统</li>
<li>使用词向量作为输入，蕴含更为丰富的语言特征</li>
<li>自动提取句子特征， 避免了人工特征设计的繁琐工作</li>
</ol>
<p><strong>Pipeline</strong></p>
<p>DMCNN</p>
<p><strong>Joint Model</strong></p>
<p>JRNN</p>
<h3 id="_21">弱监督 / 预料拓展<a class="headerlink" href="#_21" title="Permanent link">&para;</a></h3>
<p>有监督的方法需要大量的标注样本，人工标注耗时耗力，还存在一致性的问题，因此弱监督方法也是事件抽取的一个重要分支</p>
<p>弱监督/训练数据生成方面比较流行的方向有 <strong>利用外部资源，通过远程监督，以及跨语料迁移的方法</strong></p>
<h3 id="_22">事件检测与追踪<a class="headerlink" href="#_22" title="Permanent link">&para;</a></h3>
<p>主流方法包括基于相似度聚类和基于概率统计两类</p>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../../..", "features": [], "search": "../../../assets/javascripts/workers/search.e5c33ebb.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.51d95adb.min.js"></script>
      
    
  </body>
</html>